-- Drop the existing notifications table if it exists
DROP TABLE IF EXISTS public.notifications;

-- Create the notifications table with the correct columns to match the frontend expectations
CREATE TABLE public.notifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    type TEXT NOT NULL,
    message TEXT NOT NULL,
    user_id UUID REFERENCES auth.users(id),
    read_at TIMESTAMP WITH TIME ZONE,
    data JSONB
);

-- Grant permissions for the notifications table
GRANT ALL ON public.notifications TO anon;
GRANT ALL ON public.notifications TO authenticated;
GRANT ALL ON public.notifications TO service_role;

-- Create a function to fetch admin user IDs
CREATE OR REPLACE FUNCTION public.get_admin_user_ids()
RETURNS SETOF UUID AS $$
BEGIN
    RETURN QUERY SELECT id FROM auth.users WHERE raw_user_meta_data->>'role' = 'admin';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Recreate the notification trigger function to use user_id instead of recipient_role
CREATE OR REPLACE FUNCTION public.notify_admins_of_registration()
RETURNS TRIGGER AS $$
DECLARE
    admin_id UUID;
BEGIN
    -- Insert notifications for all admin users
    FOR admin_id IN SELECT * FROM public.get_admin_user_ids() LOOP
        INSERT INTO public.notifications (type, message, user_id, data)
        VALUES (
            'bus_company_registration',
            'New bus company registration: ' || NEW.company_name,
            admin_id,
            jsonb_build_object(
                'company_name', NEW.company_name,
                'email', NEW.email,
                'registration_id', NEW.id
            )
        );
    END LOOP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop and recreate the trigger
DROP TRIGGER IF EXISTS on_bus_company_registration ON public.bus_companies;
CREATE TRIGGER on_bus_company_registration
    AFTER INSERT ON public.bus_companies
    FOR EACH ROW
    EXECUTE FUNCTION public.notify_admins_of_registration(); 