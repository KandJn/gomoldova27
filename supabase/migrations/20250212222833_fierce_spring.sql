\n\n-- Create profiles table\nCREATE TABLE profiles (\n  id uuid PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,\n  email text,\n  full_name text,\n  phone text,\n  bio text,\n  avatar_url text,\n  is_driver boolean DEFAULT false,\n  id_number text,\n  driver_license text,\n  id_verified boolean DEFAULT false,\n  license_verified boolean DEFAULT false,\n  created_at timestamptz DEFAULT now(),\n  profile_completed boolean GENERATED ALWAYS AS (\n    CASE \n      WHEN full_name IS NOT NULL \n      AND phone IS NOT NULL \n      AND id_number IS NOT NULL \n      THEN true \n      ELSE false \n    END\n  ) STORED\n);
\n\n-- Create trips table\nCREATE TABLE trips (\n  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  driver_id uuid REFERENCES profiles NOT NULL,\n  "from" text NOT NULL,\n  "to" text NOT NULL,\n  date date NOT NULL,\n  time time NOT NULL,\n  price integer NOT NULL CHECK (price >= 0),\n  seats integer NOT NULL CHECK (seats > 0 AND seats <= 8),\n  created_at timestamptz DEFAULT now()\n);
\n\n-- Create bookings table\nCREATE TABLE bookings (\n  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  trip_id bigint REFERENCES trips NOT NULL,\n  user_id uuid REFERENCES profiles NOT NULL,\n  status text DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'rejected', 'cancelled')),\n  created_at timestamptz DEFAULT now(),\n  UNIQUE(trip_id, user_id)\n);
\n\n-- Create messages table\nCREATE TABLE messages (\n  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  sender_id uuid REFERENCES profiles NOT NULL,\n  receiver_id uuid REFERENCES profiles NOT NULL,\n  content text NOT NULL,\n  created_at timestamptz DEFAULT now(),\n  read_at timestamptz\n);
\n\n-- Create notifications table\nCREATE TABLE notifications (\n  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n  user_id uuid REFERENCES profiles NOT NULL,\n  type text NOT NULL,\n  content jsonb NOT NULL,\n  created_at timestamptz DEFAULT now(),\n  read_at timestamptz\n);
\n\n-- Create materialized view for seat counting\nCREATE MATERIALIZED VIEW trip_seats AS\nSELECT \n  t.id as trip_id,\n  t.seats as total_seats,\n  COUNT(b.id) as booked_seats,\n  t.seats - COUNT(b.id) as available_seats\nFROM trips t\nLEFT JOIN bookings b ON b.trip_id = t.id\nGROUP BY t.id, t.seats;
\n\n-- Enable RLS on all tables\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
\nALTER TABLE trips ENABLE ROW LEVEL SECURITY;
\nALTER TABLE bookings ENABLE ROW LEVEL SECURITY;
\nALTER TABLE messages ENABLE ROW LEVEL SECURITY;
\nALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
\n\n-- Create profile for each new user\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS trigger AS $$\nBEGIN\n  INSERT INTO public.profiles (id, email)\n  VALUES (new.id, new.email);
\n  RETURN new;
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Trigger for new user creation\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
\n\n-- Profiles policies\nCREATE POLICY "Public profiles are viewable by everyone"\n  ON profiles FOR SELECT\n  TO public\n  USING (true);
\n\nCREATE POLICY "Users can update own profile"\n  ON profiles FOR UPDATE\n  TO authenticated\n  USING (auth.uid() = id)\n  WITH CHECK (auth.uid() = id);
\n\n-- Trips policies\nCREATE POLICY "Trips are viewable by everyone"\n  ON trips FOR SELECT\n  TO public\n  USING (true);
\n\nCREATE POLICY "Users with complete profiles can create trips"\n  ON trips FOR INSERT\n  TO authenticated\n  WITH CHECK (\n    auth.uid() = driver_id AND\n    EXISTS (\n      SELECT 1 FROM profiles\n      WHERE id = auth.uid()\n      AND profile_completed = true\n      AND (\n        (is_driver = true AND license_verified = true) OR\n        is_driver = false\n      )\n    )\n  );
\n\n-- Bookings policies\nCREATE POLICY "Users can view their own bookings"\n  ON bookings FOR SELECT\n  TO authenticated\n  USING (\n    auth.uid() = user_id OR\n    EXISTS (\n      SELECT 1 \n      FROM trips \n      WHERE id = trip_id \n      AND driver_id = auth.uid()\n    )\n  );
\n\nCREATE POLICY "Users can create bookings"\n  ON bookings FOR INSERT\n  TO authenticated\n  WITH CHECK (\n    auth.uid() = user_id AND\n    EXISTS (\n      SELECT 1\n      FROM trips t\n      LEFT JOIN bookings b ON b.trip_id = t.id\n      WHERE t.id = trip_id\n      GROUP BY t.id, t.seats\n      HAVING t.seats > COUNT(b.id)\n    )\n  );
\n\n-- Messages policies\nCREATE POLICY "Users can send and receive messages"\n  ON messages FOR SELECT\n  TO authenticated\n  USING (auth.uid() IN (sender_id, receiver_id));
\n\nCREATE POLICY "Users can send messages"\n  ON messages FOR INSERT\n  TO authenticated\n  WITH CHECK (auth.uid() = sender_id);
\n\n-- Notifications policies\nCREATE POLICY "Users can view own notifications"\n  ON notifications FOR SELECT\n  TO authenticated\n  USING (auth.uid() = user_id);
\n\n-- Create function for notification on booking\nCREATE OR REPLACE FUNCTION notify_driver_on_booking()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO notifications (user_id, type, content)\n  SELECT \n    t.driver_id,\n    'booking_request',\n    jsonb_build_object(\n      'booking_id', NEW.id,\n      'trip_id', NEW.trip_id,\n      'passenger_id', NEW.user_id\n    )\n  FROM trips t\n  WHERE t.id = NEW.trip_id;
\n  RETURN NEW;
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Create trigger for booking notifications\nCREATE TRIGGER on_booking_created\n  AFTER INSERT ON bookings\n  FOR EACH ROW\n  EXECUTE FUNCTION notify_driver_on_booking();
\n\n-- Initial refresh of materialized view\nREFRESH MATERIALIZED VIEW trip_seats;
;
