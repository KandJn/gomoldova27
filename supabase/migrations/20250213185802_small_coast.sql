-- Drop all existing booking policies to avoid conflicts\nDO $$ \nBEGIN\n  -- Drop all existing policies on bookings table\n  DROP POLICY IF EXISTS "Users can create bookings" ON bookings;
\n  DROP POLICY IF EXISTS "Users can view bookings" ON bookings;
\n  DROP POLICY IF EXISTS "Users can view their bookings" ON bookings;
\n  DROP POLICY IF EXISTS "Users can view their own bookings" ON bookings;
\n  DROP POLICY IF EXISTS "Drivers can update booking status" ON bookings;
\n  DROP POLICY IF EXISTS "Drivers can update bookings" ON bookings;
\n  DROP POLICY IF EXISTS "Drivers can manage bookings" ON bookings;
\nEND $$;
\n\n-- Create simplified booking policies without recursion\nCREATE POLICY "Users can create new bookings"\n  ON bookings FOR INSERT\n  TO authenticated\n  WITH CHECK (\n    -- User must be authenticated and not the driver\n    auth.uid() = user_id AND\n    NOT EXISTS (\n      SELECT 1\n      FROM trips t\n      WHERE t.id = trip_id\n      AND t.driver_id = auth.uid()\n    ) AND\n    -- Trip must exist and have available seats\n    EXISTS (\n      SELECT 1\n      FROM trips t\n      LEFT JOIN (\n        SELECT b.trip_id, COUNT(*) as booked_seats\n        FROM bookings b\n        WHERE b.status = 'accepted'\n        GROUP BY b.trip_id\n      ) bs ON bs.trip_id = t.id\n      WHERE t.id = trip_id\n      AND t.seats > COALESCE(bs.booked_seats, 0)\n    )\n  );
\n\nCREATE POLICY "Users can view own and trip bookings"\n  ON bookings FOR SELECT\n  TO authenticated\n  USING (\n    -- Users can see their own bookings\n    auth.uid() = user_id OR\n    -- Drivers can see bookings for their trips\n    EXISTS (\n      SELECT 1\n      FROM trips t\n      WHERE t.id = trip_id\n      AND t.driver_id = auth.uid()\n    )\n  );
\n\nCREATE POLICY "Trip drivers can update bookings"\n  ON bookings FOR UPDATE\n  TO authenticated\n  USING (\n    -- Only drivers can update booking status\n    EXISTS (\n      SELECT 1\n      FROM trips t\n      WHERE t.id = trip_id\n      AND t.driver_id = auth.uid()\n    )\n  )\n  WITH CHECK (\n    -- Only allow valid status values\n    status IN ('accepted', 'rejected', 'cancelled')\n  );
\n\n-- Add function to check available seats\nCREATE OR REPLACE FUNCTION check_available_seats(trip_id bigint)\nRETURNS boolean AS $$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1\n    FROM trips t\n    LEFT JOIN (\n      SELECT b.trip_id, COUNT(*) as booked_seats\n      FROM bookings b\n      WHERE b.status = 'accepted'\n      GROUP BY b.trip_id\n    ) bs ON bs.trip_id = t.id\n    WHERE t.id = $1\n    AND t.seats > COALESCE(bs.booked_seats, 0)\n  );
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Add trigger to prevent overbooking\nCREATE OR REPLACE FUNCTION prevent_overbooking()\nRETURNS trigger AS $$\nBEGIN\n  IF NEW.status = 'accepted' AND NOT check_available_seats(NEW.trip_id) THEN\n    RAISE EXCEPTION 'No available seats for this trip';
\n  END IF;
\n  RETURN NEW;
\nEND;
\n$$ LANGUAGE plpgsql;
\n\nDROP TRIGGER IF EXISTS check_seats_before_accept ON bookings;
\nCREATE TRIGGER check_seats_before_accept\n  BEFORE UPDATE OF status ON bookings\n  FOR EACH ROW\n  WHEN (NEW.status = 'accepted')\n  EXECUTE FUNCTION prevent_overbooking();
\n\n-- Refresh materialized view\nREFRESH MATERIALIZED VIEW trip_seats;
;
