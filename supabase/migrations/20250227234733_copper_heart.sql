\n\n-- Create admin_users table\nCREATE TABLE admin_users (\n  id uuid PRIMARY KEY REFERENCES auth.users ON DELETE CASCADE,\n  role text NOT NULL CHECK (role IN ('super_admin', 'admin', 'moderator')),\n  permissions jsonb NOT NULL DEFAULT '[]'::jsonb,\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now()\n);
\n\n-- Create admin_audit_logs table\nCREATE TABLE admin_audit_logs (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  admin_id uuid REFERENCES admin_users(id) NOT NULL,\n  action text NOT NULL,\n  entity_type text NOT NULL,\n  entity_id text NOT NULL,\n  details jsonb NOT NULL DEFAULT '{}'::jsonb,\n  created_at timestamptz DEFAULT now()\n);
\n\n-- Enable RLS\nALTER TABLE admin_users ENABLE ROW LEVEL SECURITY;
\nALTER TABLE admin_audit_logs ENABLE ROW LEVEL SECURITY;
\n\n-- Create indexes\nCREATE INDEX idx_admin_users_role ON admin_users(role);
\nCREATE INDEX idx_admin_audit_logs_admin ON admin_audit_logs(admin_id);
\nCREATE INDEX idx_admin_audit_logs_action ON admin_audit_logs(action);
\nCREATE INDEX idx_admin_audit_logs_entity ON admin_audit_logs(entity_type, entity_id);
\n\n-- Create admin policies\nCREATE POLICY "Admins can view admin users"\n  ON admin_users FOR SELECT\n  TO authenticated\n  USING (\n    EXISTS (\n      SELECT 1 FROM admin_users au\n      WHERE au.id = auth.uid()\n    )\n  );
\n\nCREATE POLICY "Super admins can manage admin users"\n  ON admin_users FOR ALL\n  TO authenticated\n  USING (\n    EXISTS (\n      SELECT 1 FROM admin_users au\n      WHERE au.id = auth.uid()\n      AND au.role = 'super_admin'\n    )\n  );
\n\nCREATE POLICY "Admins can view audit logs"\n  ON admin_audit_logs FOR SELECT\n  TO authenticated\n  USING (\n    EXISTS (\n      SELECT 1 FROM admin_users au\n      WHERE au.id = auth.uid()\n    )\n  );
\n\n-- Create function to check if user is admin\nCREATE OR REPLACE FUNCTION is_admin()\nRETURNS boolean AS $$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM admin_users\n    WHERE id = auth.uid()\n  );
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Create function to check admin role\nCREATE OR REPLACE FUNCTION get_admin_role()\nRETURNS text AS $$\nBEGIN\n  RETURN (\n    SELECT role FROM admin_users\n    WHERE id = auth.uid()\n  );
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Create function to log admin actions\nCREATE OR REPLACE FUNCTION log_admin_action(\n  action text,\n  entity_type text,\n  entity_id text,\n  details jsonb DEFAULT '{}'::jsonb\n)\nRETURNS void AS $$\nBEGIN\n  IF is_admin() THEN\n    INSERT INTO admin_audit_logs (admin_id, action, entity_type, entity_id, details)\n    VALUES (auth.uid(), action, entity_type, entity_id, details);
\n  END IF;
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Create function to approve verification\nCREATE OR REPLACE FUNCTION approve_verification(\n  verification_id uuid,\n  notes text DEFAULT NULL\n)\nRETURNS void AS $$\nBEGIN\n  IF NOT is_admin() THEN\n    RAISE EXCEPTION 'Unauthorized';
\n  END IF;
\n\n  -- Update verification status\n  UPDATE verifications\n  SET \n    status = 'approved',\n    data = jsonb_set(\n      data,\n      '{admin_notes}',\n      to_jsonb(notes)\n    ),\n    updated_at = now()\n  WHERE id = verification_id;
\n\n  -- Log action\n  PERFORM log_admin_action(\n    'approve_verification',\n    'verification',\n    verification_id::text,\n    jsonb_build_object('notes', notes)\n  );
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
\n\n-- Create function to reject verification\nCREATE OR REPLACE FUNCTION reject_verification(\n  verification_id uuid,\n  reason text\n)\nRETURNS void AS $$\nBEGIN\n  IF NOT is_admin() THEN\n    RAISE EXCEPTION 'Unauthorized';
\n  END IF;
\n\n  -- Update verification status\n  UPDATE verifications\n  SET \n    status = 'rejected',\n    data = jsonb_set(\n      data,\n      '{rejection_reason}',\n      to_jsonb(reason)\n    ),\n    updated_at = now()\n  WHERE id = verification_id;
\n\n  -- Log action\n  PERFORM log_admin_action(\n    'reject_verification',\n    'verification',\n    verification_id::text,\n    jsonb_build_object('reason', reason)\n  );
\nEND;
\n$$ LANGUAGE plpgsql SECURITY DEFINER;
;
